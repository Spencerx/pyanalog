"""
C++ code generation
"""

from .ast import State, Symbol, topological_sort
from .computing_elements import cpp_impl

# could also say is_number = lambda obj: str(obj).is_digit()
is_number = lambda obj: isinstance(obj, float) or isinstance(obj, int)

import textwrap, itertools, math

cpp_template = """\
// This code was generated by PyDDA.

#include <cmath> /* don't forget -lm for linking */
#include <cfenv> /* for feenableexcept */
#include <limits> /* for signaling NAN */
#include <cstdio>

constexpr double %(nan_name)s = std::numeric_limits<double>::signaling_NaN();

%(cpp_impl)s

// Time-evolved variables, actual "state" (in general dq/dt!=0)
struct %(state_type)s {
    %(state_var_definition)s
    %(dqdt_operators)s
};

// Auxiliary variables, derived from %(state_type)s, not evolved in time (dqdt=0)
struct %(aux_type)s  {
    %(aux_var_definition)s
    void set_to_nan() {
        %(aux_var_set_to_nan)s
    }
};

// Explicit constants
static const struct %(const_type)s {
    %(explicit_constant_definitions)s
} %(const_name)s;

/// Compute the equations as given in the dda file
/// It is actually %(dqdt_name)s = f(%(state_name)s, %(aux_name)s), or at least
/// (%(dqdt_name)s,%(aux_name)s) = f(%(state_name)s).
/// %(aux_name)s is only returned for debugging and controlling purposes of intermediate results

void f(%(state_type)s const &%(state_name)s, %(state_type)s &%(dqdt_name)s, %(aux_type)s &%(aux_name)s) {
    %(aux_name)s.set_to_nan(); // only for debugging: ensure no use of uninitialized variables

    %(equations)s
}

%(state_type)s
    initial_data{ %(initial_data)s },
    dt{ %(timestep_data)s };

%(state_type)s simulate_dda(%(state_type)s initial, int max_iterations, int modulo_write, int rk_order) {
    %(state_type)s k1, k2, k3, k4, z, %(state_name)s=initial;
    %(aux_type)s %(aux_name)s;

    for(int iter = 0; iter < max_iterations; iter++) {
        switch(rk_order) {
            case 1:
                // Explicit Euler scheme
                f(%(state_name)s, k1, %(aux_name)s);
                %(state_name)s = %(state_name)s + k1*dt;
                break;
            case 2:
                // RK2 scheme
                f(%(state_name)s, k1, %(aux_name)s);
                f(%(state_name)s + k1*dt, k2, %(aux_name)s);
                %(state_name)s = %(state_name)s + (k1+k2)*dt*0.5;
                break;
            case 3:
                // Kutta's third order scheme 
                f(%(state_name)s, k1, %(aux_name)s);
                f(%(state_name)s + dt*k1*0.5, k2, %(aux_name)s);
                f(%(state_name)s + dt*k1*(-1.0) + dt*k2*2.0, k3, %(aux_name)s);
                %(state_name)s = %(state_name)s + (k1 + k2*4.0 + k3*1.0)*dt*(1./6.);
                break;
            case 4:
                // Classical RK4 scheme 
                f(%(state_name)s, k1, %(aux_name)s);
                f(%(state_name)s + dt*k1*0.5, k2, %(aux_name)s);
                f(%(state_name)s + dt*k2*0.5, k3, %(aux_name)s);
                f(%(state_name)s + dt*k3*1.0, k4, %(aux_name)s);
                %(state_name)s = %(state_name)s + (k1 + k2*2.0 + k3*2.0 + k4)*dt*(1./6.);
                break;
            default:
                exit(-42);
        }

        if(iter %% modulo_write == 0) {
            printf(%(writer_formatstring)s, %(writer_format_arguments)s);
        }
    }

    return %(state_name)s;
}

int main(int argc, char** argv) {
    feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);

    puts(%(writer_header)s); // Write CSV header

    // TODO: Make this C++ runtime arguments, not constants at code-generation time
    
    int modulo_write = %(modulo_write)d,
        max_iterations = %(max_iterations)d,
        rk_order = %(rk_order)d;

    simulate_dda(initial_data, max_iterations, modulo_write, rk_order);
}

"""

def to_cpp(state, writer_fields="All",
    modulo_write=20, max_iterations=30000, rk_order=1,
    number_precision=math.inf):
    """
    Allows for compiling DDA to a standalone C++ code.
    
    Will return a single string, the C++ code.
    
    TODO: Write some documentation :-)
    """

    indent = " "*5 # or tab, whatever you prefer - should be fit to cpp_template

    # Despite all user-chosen variable names are scoped within structs/classes, name
    # clashes are possible in some contexts. Therefore, the following names should be
    # chosen carefully.
    state_type, aux_type, const_type = "state_variables", "auxillaries", "constants"
    state_name, dqdt_name, aux_name, other_name, const_name = "_state", "_dqdt", "_aux", "_other", "_constants"
    nan_name = "_nan_"

    state = state.name_computing_elements()
    vars = state.variable_ordering()
    
    # NB: One could require that there no implicit constants, i.e. numbers appearing randomly
    #     on the RHS of expressions. One could even go further and allow numbers only in
    #     potentiometer settings
    
    if not vars.evolved:
        pass # TODO: Warn that there are (interesting) variables at all.
    if vars.aux.cyclic:
        pass # TODO: Warn that there are unwanted feedback loops

    # prepare for prefixing all RHS variables
    pystruct2cprefix = { state_name: vars.evolved, aux_name: vars.aux.all, const_name: vars.explicit_constants  }
    struct_lookup = { var: cstruct for (cstruct, pystruct) in pystruct2cprefix.items()  for var in pystruct  }
    csymbol = lambda var: f"{struct_lookup[var]}.{var}"
    prefix_rhs = lambda el: Symbol(csymbol(el.head)) if el.is_variable() else el
    
    def number2cstr(number):
        if not is_number(number):
            raise ValueError(f"Was expecting a number, but got {type(number)} with value {number}.")
        formatstring = f"%{number_precision}f" if number_precision < math.inf else "%f"
        return formatstring % number
    
    # Remove any const() which remained. Would be nicer to assert not having consts() at all.
    remove_const = lambda x: number2cstr(x.tail[0]) if isinstance(x,Symbol) and x.head=="const" else x
    
    # Translate const(foo) by stripping foo or some bar by looking up if it is an explicit constant.
    # Dynamical variables are not allowed here.
    def lookup_const(var):
        if isinstance(var,Symbol):
            if var.head == "const":
                var = var.tail[0] # continue
            elif var.is_variable():
                if not var.head in vars.explicit_constants:
                    raise ValueError(f"Only constants allowed in this context. {var} however refers to {csymbol(var.head)}.")
                return csymbol(var.head)
            else: # remaining case: var.is_term()
                raise ValueError(f"Was expecting const(foo) or so, but got term {var}.")
        if not is_number(var): raise ValueError(f"Got a weird {type(var)} in a constant context: {var}")
        return number2cstr(var)

    # rename reserved keywords in the C language
    #c_names = { "const": "constant", "int": "Int", "div": "Div" }
    #c_substitute = lambda head: c_names.get(head, head)
    #c_state = State({ var: map_heads(state[var], c_substitute) for var in state })

    # Extract int(..., timestep, initial_data) and rewrite reserved C keyword
    timesteps = {}
    initial_data = {}
    def map_and_treat_integrals(var):
        if not var in vars.evolved: return state[var]
        tail = state[var].tail
        if not len(tail) >= 3: raise ValueError("int(...) requires at least int(value, dt, ic)")
        timesteps[var] = lookup_const(tail[-2])
        initial_data[var] = lookup_const(tail[-1])
        return Symbol("Int", *tail[0:len(tail)-2])
    state = State({ var: map_and_treat_integrals(var) for var in state })

    
    # do the renaming *after* variable dependency analysis
    state = state.map_tails(remove_const)
    state = state.map_tails(prefix_rhs)
        
    # C-format lists of statements or so. Do indentation.
    J = lambda whatever: ", ".join(whatever)
    C = lambda whatever: textwrap.indent(whatever if isinstance(whatever, str) else  "\n".join(whatever), indent)
    CC = lambda whatevr: C(C(whatevr)) # two indentations ;-)
    varlist = lambda ctype, lst: C(textwrap.wrap(f"{ctype} {', '.join(lst)};", width=50)) if lst else ""

    state_var_definition = varlist("double", vars.evolved)
    aux_var_definition = varlist("double", vars.aux.all)
    all_variables_as_string = C(f'"{var}",' for var in vars.all)

    # For debugging:
    aux_var_set_to_nan = C(f"{var} = {nan_name};" for var in vars.aux.all)
    
    explicit_constant_definitions = varlist("constexpr static double", 
        (f"{var}={state[var].tail[0]}" for var in vars.explicit_constants)) # extract x in const(x)

    initial_data = J(str(initial_data[var]) for var in vars.evolved)
    timestep_data = J(str(timesteps[var]) for var in vars.evolved)

    #state_assignments = lambda lst: C(f"{v} = {state[v]};" for v in lst)) if lst else C("/* none */")
    state_assignments = lambda lhs_struct,lst: [f"{lhs_struct}.{var} = {state[var]};" for var in lst] if lst else ["/* none */"]

    # The dependency is basically
    #   aux = function_of(aux, state)
    #   dqdt = function_of(aux, state)
    # and in the integration schema step
    #   state = function_of(dqdt)
    
    equations = []
    equations.append("// 1. Topologically sorted aux variables")
    equations += state_assignments(aux_name, vars.aux.sorted)
    equations.append("// 2. Cyclic aux variables")
    equations += state_assignments(aux_name, vars.aux.cyclic)
    equations.append("// 3. State variable changes (dqdt), finally")
    equations += state_assignments(dqdt_name, vars.evolved)
    equations.append("// 4. Unneeded auxilliary variables (maybe postprocessing, etc.)")
    equations += state_assignments(aux_name, vars.aux.unneeded)
    equations = C(equations)

    if writer_fields == "All":
        writer_fields = vars.all
    writer_header = '"'+" ".join(writer_fields)+'"'
    writer_format_arguments = J(csymbol(var) for var in writer_fields)
    writer_formatstring = '"'+" ".join('%f' for var in writer_fields)+"\\n\""

    make_operator = lambda operator_symbol, other_type, a=True: [ \
        f"{state_type} operator{operator_symbol}(const {other_type} &{other_name}) const "+'{', \
        C(f"{state_type} {state_name};"), \
        C(f"{state_name}.{var} = {var} {operator_symbol} {other_name}{'.'+var if a else ''};" for var in vars.evolved), \
        C(f"return {state_name};"), \
        "}"]

    dqdt_operators = C(C(make_operator(s,o,a)) for s,(o,a) in
        itertools.product("*+", zip((state_type, "double"), (True,False))))

    output = cpp_template % {**locals(), **globals()}
    return output

# What follows are a few helper functions to make the usage nicer

def compile(code, c_filename="generated.cc", compiler="g++", compiler_output="a.out", options="-Wall"):
    """
    Write code to c_filename and run the compiler on that, afterwards.
    Will raise an error if compilation fails.
    """
    from os import system
    with open(c_filename, "w") as fh:
        print(code, file=fh)
    if system(f"{compiler} -o{compiler_output} {options} {c_filename}"):
        raise ValueError("Could not compile C source!")

def run(command="./a.out"):
    """
    Run an executable and pipe the stdout to a string, which is returned.
    Stderr will just be passed.
    The function will return once the binary finished or raise in case of error.
    """
    import subprocess, io, sys
    #stdout, stderr = io.StringIO(), io.StringIO()
    proc = subprocess.Popen([command], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    #proc.wait()
    
    # instead of proc.wait(), which could deadlock when the stdout buffer
    # is full, do this:
    stdout, stderr = "", ""
    while proc.poll() == None:
        stdout += proc.stdout.read()
        stderr += proc.stderr.read()
    stdout += proc.stdout.read()
    stderr += proc.stderr.read()
    #stdout, stderr = stdout.getvalue(), stderr.getvalue()
    if proc.returncode:
        print(stdout)
        print("STDERR:", stderr)
        raise ValueError(f"Could not execute '{command}'. Please run on the command line for inspection. Probably use gdb.")
    else:
        return stdout
